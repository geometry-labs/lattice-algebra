{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"lattice-algebra \u00b6 Infrastructure package for lattice-based crypto.","title":"Index"},{"location":"#lattice-algebra","text":"Infrastructure package for lattice-based crypto.","title":"lattice-algebra"},{"location":"cryptography/","text":"Cryptography \u00b6 For certain choices of d , q , and l , it is thought to be hard to find any vector (or matrix) x that is small enough (in terms of one or more norms on the ring R ) such that some matrix equation A * x = 0 is satisfied, where A is a suitably random challenge from V . From this hardness assumption, the map carrying suitably small vectors (or matrices) x to their images A * x is a one-way function. If no additional information is leaked about a small secret vector (such as how long it takes to perform arithmetic operations), then this can be used to build secure cryptographic schemes. Simulation-based security proofs in the lattice setting are based on extracting a suitably small vector or matrix (called a witness ) that satisfies some system of linear equations. Overall security of the scheme is based on how small the adversary can make this witness in terms of the norm. The infinity-norm and the one-norm are of particular interest: the infinity-norm of a polynomial is the absolute maximum coefficient, and the one-norm is the absolute sum of coefficients. We can extend this definition to vectors by taking the maximum norm of the entries of the vector. We note that if we count only the weight of a polynomial, in terms of the number of non-zero coefficients, then we have that one_norm <= infinity_norm * weight . Consequently, bounding the infinity norm and the weight of a polynomial also has the effect of bounding the infinity norm and the one-norm. Taking into account both the infinity norm and the weight of the polynomial (number of non-zero entries) enables tighter inequalities that lead to smaller witnesses. This means we can achieve the same security level with smaller parameters (the CRYSTALS-Dilithium scheme is an exemplary implementation of this technique). Nothing in lattice-algebra limits which hardness assumptions are underlying the cryptographic scheme being constructed. Since the library merely handles polynomials from R and vectors from V=R^l , schemes based on other hardness assumptions (such as the Ring Learning With Errors assumption) that take place over the same ring can be securely implemented as well .","title":"Cryptography"},{"location":"cryptography/#cryptography","text":"For certain choices of d , q , and l , it is thought to be hard to find any vector (or matrix) x that is small enough (in terms of one or more norms on the ring R ) such that some matrix equation A * x = 0 is satisfied, where A is a suitably random challenge from V . From this hardness assumption, the map carrying suitably small vectors (or matrices) x to their images A * x is a one-way function. If no additional information is leaked about a small secret vector (such as how long it takes to perform arithmetic operations), then this can be used to build secure cryptographic schemes. Simulation-based security proofs in the lattice setting are based on extracting a suitably small vector or matrix (called a witness ) that satisfies some system of linear equations. Overall security of the scheme is based on how small the adversary can make this witness in terms of the norm. The infinity-norm and the one-norm are of particular interest: the infinity-norm of a polynomial is the absolute maximum coefficient, and the one-norm is the absolute sum of coefficients. We can extend this definition to vectors by taking the maximum norm of the entries of the vector. We note that if we count only the weight of a polynomial, in terms of the number of non-zero coefficients, then we have that one_norm <= infinity_norm * weight . Consequently, bounding the infinity norm and the weight of a polynomial also has the effect of bounding the infinity norm and the one-norm. Taking into account both the infinity norm and the weight of the polynomial (number of non-zero entries) enables tighter inequalities that lead to smaller witnesses. This means we can achieve the same security level with smaller parameters (the CRYSTALS-Dilithium scheme is an exemplary implementation of this technique). Nothing in lattice-algebra limits which hardness assumptions are underlying the cryptographic scheme being constructed. Since the library merely handles polynomials from R and vectors from V=R^l , schemes based on other hardness assumptions (such as the Ring Learning With Errors assumption) that take place over the same ring can be securely implemented as well .","title":"Cryptography"},{"location":"installation/","text":"Installation and Building Docs \u00b6 To install this library, run: pip install lattice-algebra Docs are built with mkdocs; first use pip install -r docs/requirements.txt , then use mkdocs serve , then navigate to http://127.0.0.1:8000/lattice-algebra/ .","title":"Installation"},{"location":"installation/#installation-and-building-docs","text":"To install this library, run: pip install lattice-algebra Docs are built with mkdocs; first use pip install -r docs/requirements.txt , then use mkdocs serve , then navigate to http://127.0.0.1:8000/lattice-algebra/ .","title":"Installation and Building Docs"},{"location":"intended_usage/","text":"Intended Usage (and Some Background) \u00b6 Arithmetic \u00b6 For some TLDR code snippets, proceed to the Example below. In many lattice-based cryptographic schemes, primitives are constructed from polynomials in the ring R = Zq[X]/(X^d + 1) where we denote the integers modulo a prime q with Zq , with a degree d that is a power of two such that (q-1) % (2*d) = 0 . Keys are often vectors from the vector space V=R^l or matrices with entries from V = R^(k * l) for dimensions k , l . For example, the CRYSTALS-Dilithium scheme sets q = 2^23 - 2^13 + 1 , d = 256 , and uses 4x4 , 6x5 , and 8x7 matrices, depending on security level. We encode the vector space V using the LatticeParameters object which holds the degree , modulus , and length attributes. We create polynomials in R by using the Polynomial object, which has a LatticeParameters attribute called lp . When we instantiate a Polynomial, we pass in the lattice parameters and a coefficient representation of that polynomial as a dictionary. The keys determine the power on the monomial and the value determines the coefficient. For example, if degree = 8 and modulus = 257 , then the polynomial f(X) = 1 + 256 * X + 12 * X**2 can be created with either {0: 1, 1: 256, 2: 12} or {0: 1, 1: -1, 2: 12} as the input coefficient representation, since (256 - (-1)) % 257 == 0 . We create polynomial vectors in V by using the PolynomialVector object, which has a LatticeParameters attribute and another attribute called entries which is just a list of Polynomial objects. For example, if f and g are Polynomial and have the same lattice parameters, which has l = 2 , then we can instantiate the vector v = [f, g] by passing in entries=[f, g] . From a Polynomial , we can access the NTT representation at any time for almost no cost with the ntt_representation attribute. However, regaining the coefficient representation requires computing the inverse NTT, which is costly. Checking norms and weights of a Polynomial or a PolynomialVector requires the coefficient representation. We re-emphasize that this representation is costly to compute. Thus, it should only be computed once (and norms and weights should only be checked at the end of algorithms). We regain the coefficient representation of a Polynomial or a PolynomialVector object by calling the get_coef_rep function. Example of Arithmetic \u00b6 Consider the vector space V defined with degree = 8 , modulus = 257 , and length = 3 , and the following 8 polynomials (which are proportional to the first seven Legendre polynomials, for a convenient example). a(X) = 1 b(X) = X c(X) = -1 + 3 * X**2 d(X) = -3 * X + 5 * X ** 3 e(X) = 3 - 30 * X ** 2 + 35 * X ** 4 f(X) = 15 * X - 70 * X ** 3 + 63 * X ** 5 g(X) = -5 + 105 * X ** 2 - 315 * X ** 4 + 231 * X ** 6 h(X) = -35 * X + 315 * X ** 3 - 693 * X ** 5 + 429 * X ** 7 In the following code, we instantiate the vector space V = R^3 , we instantiate these polynomials, we compute a few of their sums and products, we create two vectors of polynomials, v = [a, b, c] and u = [d, e, f] , we compute the dot product v * u of these two vectors, we compare it to the sums and products we just computed by calling the get_coef_rep function, we scale v by g(X) and we scale u by h(X) , we compute this linear combination of v and u , and we print the coefficient representation, norm, and weight. from lattice_algebra import LatticeParameters, Polynomial, PolynomialVector lp = LatticeParameters(pars={'degree': 8, 'modulus': 257, 'length': 3}) # make V a = Polynomial(lp = lp, coefs = {0: 1}) # Make 8 polynomials proportional to the first 8 Legendre polys b = Polynomial(lp = lp, coefs = {1: 1}) c = Polynomial(lp = lp, coefs = {0: -1, 2: 3}) d = Polynomial(lp = lp, coefs = {1: -3, 3: 5}) e = Polynomial(lp = lp, coefs = {0: 3, 2: -30, 4: 35}) f = Polynomial(lp = lp, coefs = {1: 15, 3: -70, 5: 63}) g = Polynomial(lp = lp, coefs = {0: -5, 2: 105, 4: -315, 6: 231}) h = Polynomial(lp = lp, coefs = {1: -35, 3: 315, 5: -693, 7: 429}) prods = [a * d, b * e, c * f] # We can add, subtract, multiply, and use python built-in sum() sum_of_these = sum(prods) coef_rep_of_sum, n_sum, n_sum = sum_of_these.get_coef_rep() v = PolynomialVector(lp = lp, entries = [a, b, c]) # Make some polynomial vectors u = PolynomialVector(lp = lp, entries = [d, e, f]) dot_product = v * u # We can compute the dot product, which should match the sum above coef_rep_of_dot_prod, n_dot, w_dot = dot_product.get_coef_rep() assert n_sum == n_dot assert w_sum == w_dot assert list(coef_rep_of_dot_prod.keys()) == list(coef_rep_of_sum.keys()) for next_monomial in coef_rep_of_dot_prod: assert (coef_rep_of_dot_prod[next_monomial] - coef_rep_of_sum[next_monomial]) % lp.modulus == 0 scaled_v = v ** g # We can also scale a vector by a polynomial with __pow__ scaled_u = u ** h lin_combo = scaled_v + scaled_u # We can add vectors (and subtract!) also_lin_combo = sum([i ** j for i, j in zip([v, u], [g, h])]) # more pythonically assert also_lin_combo == lin_combo # Lastly, let's print the coefficient representation, norm, and weight of this lin combo coef_rep, n, w = lin_combo.get_coef_rep() print(f\"Coefficient representation of linear combination = {coef_rep}\") print(f\"Norm of linear combination = {n}\") print(f\"Weight of linear combination = {w}\") Randomness and Hashing \u00b6 The library also contains functions random_polynomial , hash2bddpoly , random_polynomialvector , and hash2bddpolyvec for generating random Polynomial and PolynomialVector objects, either with system randomness or by hashing a message. The output of these functions are uniformly random (at least up to a negligible difference) among the Polynomial and PolynomialVector objects with a specified infinity norm bound and Hamming weight. Randomness is generated using the secrets module. Example of Randomness and Hashing. \u00b6 In the following code, we first use the salt 'SOME_SALT' to hash the string hello world to an instance of the Polynomial class, say x , and an instance of the PolynomialVector class, say v . In both cases, the polynomials in the hash output should have at most 4 non-zero coefficients since wt = 4 , and all of those should be in the list [-1, 0, 1] since bd = 1 . Then, we sample a new random Polynomial , say y , and a new random PolynomialVector , say u , using random_polynomial and random_polynomialvector , respectively. Note that there are around 2 ** 12 possible outputs of random_polynomial and hash2bddpoly using these parameters, and around 2 ** 36 possible outputs of random_polynomialvector and hash2bddpolyvec . In particular, the chance that we obtain x == y and v == u under these conditions is around 2 ** -48 . While this is not cryptographically small, it is pretty durned small, so the following code should pass assertions. from lattice_algebra import hash2bddpoly, hash2bddpolyvec, random_polynomial, random_polynomialvector lp = LatticeParameters(pars={'degree': 8, 'modulus': 257, 'length': 3}) # make V x = hash2bddpoly(secpar = lp.secpar, lp = lp, bd = 1, wt = 4, salt = 'SOME_SALT', m='hello world') coef_rep, n, w = x.get_coef_rep() assert n <= 1 # should always pass assert len(coef_rep) <= w <= 4 # should always pass v = hash2bddpoly(secpar = lp.secpar, lp = lp, bd = 1, wt = 4, salt = 'SOME_SALT', m='hello world') coef_rep, n, w = v.get_coef_rep() assert n <= 1 # should always pass assert len(coef_rep) <= w <= 4 # should always pass y = random_polynomial(secpar = lp.secpar, lp = lp, bd = 1, wt = 4) coef_rep, n, w = y.get_coef_rep() assert n <= 1 # should always pass assert len(coef_rep) <= w <= 4 # should always pass u = random_polynomialvector(secpar = lp.secpar, lp = lp, bd = 1, wt = 4) coef_rep, n, w = u.get_coef_rep() assert n <= 1 # should always pass sassert len(coef_rep) <= w <= 4 # should always pass assert x != y or v != u # should pass with probability 1 - 2 ** - 48 In order for the hash functions to work requires decoding bitstrings of certain lengths to Polynomial and PolynomialVector objects in a way that keeps the output uniformly random (or at least with a negligible difference from uniform). These are the functions decode2coeef , decode2coefs , decode2indices , and decode2polycoefs .","title":"Intended Usage"},{"location":"intended_usage/#intended-usage-and-some-background","text":"","title":"Intended Usage (and Some Background)"},{"location":"intended_usage/#arithmetic","text":"For some TLDR code snippets, proceed to the Example below. In many lattice-based cryptographic schemes, primitives are constructed from polynomials in the ring R = Zq[X]/(X^d + 1) where we denote the integers modulo a prime q with Zq , with a degree d that is a power of two such that (q-1) % (2*d) = 0 . Keys are often vectors from the vector space V=R^l or matrices with entries from V = R^(k * l) for dimensions k , l . For example, the CRYSTALS-Dilithium scheme sets q = 2^23 - 2^13 + 1 , d = 256 , and uses 4x4 , 6x5 , and 8x7 matrices, depending on security level. We encode the vector space V using the LatticeParameters object which holds the degree , modulus , and length attributes. We create polynomials in R by using the Polynomial object, which has a LatticeParameters attribute called lp . When we instantiate a Polynomial, we pass in the lattice parameters and a coefficient representation of that polynomial as a dictionary. The keys determine the power on the monomial and the value determines the coefficient. For example, if degree = 8 and modulus = 257 , then the polynomial f(X) = 1 + 256 * X + 12 * X**2 can be created with either {0: 1, 1: 256, 2: 12} or {0: 1, 1: -1, 2: 12} as the input coefficient representation, since (256 - (-1)) % 257 == 0 . We create polynomial vectors in V by using the PolynomialVector object, which has a LatticeParameters attribute and another attribute called entries which is just a list of Polynomial objects. For example, if f and g are Polynomial and have the same lattice parameters, which has l = 2 , then we can instantiate the vector v = [f, g] by passing in entries=[f, g] . From a Polynomial , we can access the NTT representation at any time for almost no cost with the ntt_representation attribute. However, regaining the coefficient representation requires computing the inverse NTT, which is costly. Checking norms and weights of a Polynomial or a PolynomialVector requires the coefficient representation. We re-emphasize that this representation is costly to compute. Thus, it should only be computed once (and norms and weights should only be checked at the end of algorithms). We regain the coefficient representation of a Polynomial or a PolynomialVector object by calling the get_coef_rep function.","title":"Arithmetic"},{"location":"intended_usage/#example-of-arithmetic","text":"Consider the vector space V defined with degree = 8 , modulus = 257 , and length = 3 , and the following 8 polynomials (which are proportional to the first seven Legendre polynomials, for a convenient example). a(X) = 1 b(X) = X c(X) = -1 + 3 * X**2 d(X) = -3 * X + 5 * X ** 3 e(X) = 3 - 30 * X ** 2 + 35 * X ** 4 f(X) = 15 * X - 70 * X ** 3 + 63 * X ** 5 g(X) = -5 + 105 * X ** 2 - 315 * X ** 4 + 231 * X ** 6 h(X) = -35 * X + 315 * X ** 3 - 693 * X ** 5 + 429 * X ** 7 In the following code, we instantiate the vector space V = R^3 , we instantiate these polynomials, we compute a few of their sums and products, we create two vectors of polynomials, v = [a, b, c] and u = [d, e, f] , we compute the dot product v * u of these two vectors, we compare it to the sums and products we just computed by calling the get_coef_rep function, we scale v by g(X) and we scale u by h(X) , we compute this linear combination of v and u , and we print the coefficient representation, norm, and weight. from lattice_algebra import LatticeParameters, Polynomial, PolynomialVector lp = LatticeParameters(pars={'degree': 8, 'modulus': 257, 'length': 3}) # make V a = Polynomial(lp = lp, coefs = {0: 1}) # Make 8 polynomials proportional to the first 8 Legendre polys b = Polynomial(lp = lp, coefs = {1: 1}) c = Polynomial(lp = lp, coefs = {0: -1, 2: 3}) d = Polynomial(lp = lp, coefs = {1: -3, 3: 5}) e = Polynomial(lp = lp, coefs = {0: 3, 2: -30, 4: 35}) f = Polynomial(lp = lp, coefs = {1: 15, 3: -70, 5: 63}) g = Polynomial(lp = lp, coefs = {0: -5, 2: 105, 4: -315, 6: 231}) h = Polynomial(lp = lp, coefs = {1: -35, 3: 315, 5: -693, 7: 429}) prods = [a * d, b * e, c * f] # We can add, subtract, multiply, and use python built-in sum() sum_of_these = sum(prods) coef_rep_of_sum, n_sum, n_sum = sum_of_these.get_coef_rep() v = PolynomialVector(lp = lp, entries = [a, b, c]) # Make some polynomial vectors u = PolynomialVector(lp = lp, entries = [d, e, f]) dot_product = v * u # We can compute the dot product, which should match the sum above coef_rep_of_dot_prod, n_dot, w_dot = dot_product.get_coef_rep() assert n_sum == n_dot assert w_sum == w_dot assert list(coef_rep_of_dot_prod.keys()) == list(coef_rep_of_sum.keys()) for next_monomial in coef_rep_of_dot_prod: assert (coef_rep_of_dot_prod[next_monomial] - coef_rep_of_sum[next_monomial]) % lp.modulus == 0 scaled_v = v ** g # We can also scale a vector by a polynomial with __pow__ scaled_u = u ** h lin_combo = scaled_v + scaled_u # We can add vectors (and subtract!) also_lin_combo = sum([i ** j for i, j in zip([v, u], [g, h])]) # more pythonically assert also_lin_combo == lin_combo # Lastly, let's print the coefficient representation, norm, and weight of this lin combo coef_rep, n, w = lin_combo.get_coef_rep() print(f\"Coefficient representation of linear combination = {coef_rep}\") print(f\"Norm of linear combination = {n}\") print(f\"Weight of linear combination = {w}\")","title":"Example of Arithmetic"},{"location":"intended_usage/#randomness-and-hashing","text":"The library also contains functions random_polynomial , hash2bddpoly , random_polynomialvector , and hash2bddpolyvec for generating random Polynomial and PolynomialVector objects, either with system randomness or by hashing a message. The output of these functions are uniformly random (at least up to a negligible difference) among the Polynomial and PolynomialVector objects with a specified infinity norm bound and Hamming weight. Randomness is generated using the secrets module.","title":"Randomness and Hashing"},{"location":"intended_usage/#example-of-randomness-and-hashing","text":"In the following code, we first use the salt 'SOME_SALT' to hash the string hello world to an instance of the Polynomial class, say x , and an instance of the PolynomialVector class, say v . In both cases, the polynomials in the hash output should have at most 4 non-zero coefficients since wt = 4 , and all of those should be in the list [-1, 0, 1] since bd = 1 . Then, we sample a new random Polynomial , say y , and a new random PolynomialVector , say u , using random_polynomial and random_polynomialvector , respectively. Note that there are around 2 ** 12 possible outputs of random_polynomial and hash2bddpoly using these parameters, and around 2 ** 36 possible outputs of random_polynomialvector and hash2bddpolyvec . In particular, the chance that we obtain x == y and v == u under these conditions is around 2 ** -48 . While this is not cryptographically small, it is pretty durned small, so the following code should pass assertions. from lattice_algebra import hash2bddpoly, hash2bddpolyvec, random_polynomial, random_polynomialvector lp = LatticeParameters(pars={'degree': 8, 'modulus': 257, 'length': 3}) # make V x = hash2bddpoly(secpar = lp.secpar, lp = lp, bd = 1, wt = 4, salt = 'SOME_SALT', m='hello world') coef_rep, n, w = x.get_coef_rep() assert n <= 1 # should always pass assert len(coef_rep) <= w <= 4 # should always pass v = hash2bddpoly(secpar = lp.secpar, lp = lp, bd = 1, wt = 4, salt = 'SOME_SALT', m='hello world') coef_rep, n, w = v.get_coef_rep() assert n <= 1 # should always pass assert len(coef_rep) <= w <= 4 # should always pass y = random_polynomial(secpar = lp.secpar, lp = lp, bd = 1, wt = 4) coef_rep, n, w = y.get_coef_rep() assert n <= 1 # should always pass assert len(coef_rep) <= w <= 4 # should always pass u = random_polynomialvector(secpar = lp.secpar, lp = lp, bd = 1, wt = 4) coef_rep, n, w = u.get_coef_rep() assert n <= 1 # should always pass sassert len(coef_rep) <= w <= 4 # should always pass assert x != y or v != u # should pass with probability 1 - 2 ** - 48 In order for the hash functions to work requires decoding bitstrings of certain lengths to Polynomial and PolynomialVector objects in a way that keeps the output uniformly random (or at least with a negligible difference from uniform). These are the functions decode2coeef , decode2coefs , decode2indices , and decode2polycoefs .","title":"Example of Randomness and Hashing."},{"location":"introduction/","text":"Introduction \u00b6 The math handled by this package is foundational for lattice algebra, with a variety of applications ranging from signature aggregation to zero-knowledge proofs. The module highly prioritizes developer experience for researchers and engineers, by allowing them to work with a few high level objects (e.g. polynomials, polynomial vectors) that contain built-in methods to abstractly handle the ways that they interact with each other. The goal is to lower the barrier for creating lattice cryptography primitives and applications by allowing the developers to focus on securely building the higher-level constructs without having to worry about implementing the underlying algebra as well. The module is specifically designed for building cryptographic schemes in the Ring/Module/Ideal Short Integer Solution setting with secrets uniformly distributed with respect to the infinity-norm and one-norm; it can also be used to implement schemes in the Ring/Module/Ideal Learning With Errors setting. High level objects are efficiently implemented under the hood: to manipulate equations of polynomials, we carry out the computations with vectors and matrices, with optimized algebraic operations.","title":"Introduction"},{"location":"introduction/#introduction","text":"The math handled by this package is foundational for lattice algebra, with a variety of applications ranging from signature aggregation to zero-knowledge proofs. The module highly prioritizes developer experience for researchers and engineers, by allowing them to work with a few high level objects (e.g. polynomials, polynomial vectors) that contain built-in methods to abstractly handle the ways that they interact with each other. The goal is to lower the barrier for creating lattice cryptography primitives and applications by allowing the developers to focus on securely building the higher-level constructs without having to worry about implementing the underlying algebra as well. The module is specifically designed for building cryptographic schemes in the Ring/Module/Ideal Short Integer Solution setting with secrets uniformly distributed with respect to the infinity-norm and one-norm; it can also be used to implement schemes in the Ring/Module/Ideal Learning With Errors setting. High level objects are efficiently implemented under the hood: to manipulate equations of polynomials, we carry out the computations with vectors and matrices, with optimized algebraic operations.","title":"Introduction"},{"location":"under_the_hood/","text":"Under the Hood \u00b6 The library is designed to make it easy for developers to write clean code that securely implements lattice-based cryptography for protocols and applications. The package is optimized to use the Number Theoretic Transform (NTT) to multiply polynomials in time O(2dlog(2d)) , and uses constant-time modular arithmetic to avoid timing attacks . For convenience, we included tools for both hashing to and sampling from these \"suitably small\" polynomials and vectors. Both the hashing and sampling are carried out such that the bias of the resulting distribution is negligibly different from uniform. One way that the lattice-algebra toolkit helps developers write succinct code is by leveraging python's magic methods for arithmetic with elements from R and R^l . For example, suppose we have two polynomials f and g . Simple expressions such as f + g , f - g , and f * g carry out constant-time polynomial arithmetic such as addition, subtraction, and multiplication (respectively). Likewise if we have two vectors of polynomials x and y , several vector arithmetic methods are at our disposal: we can add them like x + y , or calculate the dot product as x * y . Additionally, x ** f scales a vector x by the polynomial f , which is useful for constructing digital signatures. Class Details \u00b6 This package handles three fundamental objects: LatticeParameters, Polynomial, and PolynomialVector. The Polynomial and PolynomialVector objects have a LatticeParameters attribute, and the package handles computations with Polynomial and PolynomialVector objects with matching LatticeParameters. LatticeParameters \u00b6 The LatticeParameters class contains attributes describing the ring R , namely the degree d , the module length l , and the modulus q . From these, additional data are pre-computed for use in various algorithms later. We instantiate a LatticeParameters object by specifying the degree, length, and modulus in the following way. lp = LatticeParameters(degree=2**10, length=2**4, modulus=12289) We must instantiate LatticeParameters objects by passing in degree, length, and modulus. These must all be positive integers such that the degree is a power of two and (modulus - 1) % (2 * degree) == 0 otherwise a ValueError is raised. Polynomial \u00b6 Attributes and Instantiation \u00b6 The Polynomial and PolynomialVector objects have a LatticeParameters attribute, lp , and the package handles computations with Polynomial and PolynomialVector objects with matching LatticeParameters. Other than the LatticeParameters object attached to each Polynomial, the Polynomial object also has an ntt_representation attribute, which is a list of integers. To instantiate a Polynomial, we pass in the coefficient representation of the polynomial as a dictionary of key-value pairs, where the keys are integers in the set [0, 1, ..., degree - 1] and the value associated with a key is the coefficient of the associated monomial, which is assumed to be a representative of an equivalence class of integers modulo modulus . The coefficients are centralized to be in the list [-(modulus//2), -(modulus//2)+1, ..., modulus//2 - 1, modulus//2] with constant-time modular arithmetic. For example, if modulus = 61 and we want to represent 3 * X**2 + 9 * X + 17 , we see the coefficient on the monomial X**0 = 1 is 17 , the coefficient on the monomial X is 9 , and the coefficient on the monomial X**2 is 3 . So we can pack the coefficient representation of this polynomial into a dictionary like {0: 17, 1: 9, 2: 3} . So, to create a Polynomial object representing this polynomial, we use the following. f = Polynomial(pars=lp, coefs={0: 17, 1: 9, 2: 3}) Arithmetic \u00b6 Polynomials support __add__ , __radd__ , __sub__ , __mul__ , and __rmul__ . Thus, for two polynomials, say f and g , we simply use f + g , f - g , and f*g for addition, subtraction, and multiplication. Arithmetic for these operations take place coordinate-wise with the ntt_representation list, so they are very fast. Polynomial Norm, Weight, and String Representation \u00b6 Polynomials have a cooefficient_representation_and_norm_and_weight method, which inverts the ntt_representation list to obtain the coefficient representation of the polynomial, and returns this coefficient representation together with the infinity norm and the Hamming weight of the polynomial. The package uses __repr___ to cast the output of get_coef_rep as a string. WARNING : Computing the ntt_representation requires computing the NTT of the polynomial, and calling get_coef_rep requires computing the inverse NTT of the polynomial. These are relatively expensive operations compared to arithmetic. Hence, creating polynomials , printing them to strings , and computing the norm and weight of polynomials should be done once, after all other computations are complete. PolynomialVector \u00b6 PolynomialVector Attributes and Instantiation \u00b6 The Polynomial and PolynomialVector objects have a LatticeParameters attribute, par , and the package handles computations with Polynomial and PolynomialVector objects with matching LatticeParameters. Other than the LatticeParameters object attached to each PolynomialVector has an entries attribute, which is just a list of Polynomial objects. To instantiate a PolynomialVector, we pass in a list of Polynomial objects as the entries. For example, if f is the Polynomial from the previous section and g(X) = -17 + 12 * X ** 2 , we can create g and create a PolynomialVector object in the following way. g = Polynomial(pars=lp, coefs={0: -17, 2: 12}) v = PolynomialVector(pars=lp, entries=[f, g]) Each Polynomial in entries must have the same LatticeParameters object as v and we must have len(entries) == lp.length . PolynomialVector Addition, Subtraction, Scaling, and Dot Products \u00b6 PolynomialVector objects support __add__ , __radd__ , and __sub__ to define addition and subtraction between PolynomialVector objects. This way, for two PolynomialVector objects, say v and w , we can just use v + w and v - w to compute the sum and difference, respectively. The package uses __mul__ and __rmul__ to define the dot product between two PolynomialVector objects. The dot product outputs a Polynomial object. For example, if v.entries == [f, g] and w.entries == [a, b] , then v * w returns f * a + g * b . The package repurposes __pow__ to scale a PolynomialVector by a Polynomial. For example, if v.entries = [f, g] and a is some Polynomial object, then v ** a = [a * f, a * g] . This is not exponentiation, although we use the notation for exponentiation. Hence, to compute a linear combination of PolynomialVectors whose coefficients are Polynomials, we compute the sum of \"exponents\" with something like this: sum(f ** a for f, a in zip(some_polynomial_vectors, some_polynomials)) . As before, arithmetic operations are done using the ntt_representation of the involved polynomials, and are thus quite fast. PolynomialVector Norm, Weight, and String Representation. \u00b6 The string representation of a PolynomialVector, defined in __repr__ is merely str(entries) . WARNING : Like for Polynomial , instantiation requires computing the NTT of polynomials. So our previous warning about the cost of computing the NTT and the inverse NTT applies here, but with the added curse of dimensionality.","title":"Under The Hood"},{"location":"under_the_hood/#under-the-hood","text":"The library is designed to make it easy for developers to write clean code that securely implements lattice-based cryptography for protocols and applications. The package is optimized to use the Number Theoretic Transform (NTT) to multiply polynomials in time O(2dlog(2d)) , and uses constant-time modular arithmetic to avoid timing attacks . For convenience, we included tools for both hashing to and sampling from these \"suitably small\" polynomials and vectors. Both the hashing and sampling are carried out such that the bias of the resulting distribution is negligibly different from uniform. One way that the lattice-algebra toolkit helps developers write succinct code is by leveraging python's magic methods for arithmetic with elements from R and R^l . For example, suppose we have two polynomials f and g . Simple expressions such as f + g , f - g , and f * g carry out constant-time polynomial arithmetic such as addition, subtraction, and multiplication (respectively). Likewise if we have two vectors of polynomials x and y , several vector arithmetic methods are at our disposal: we can add them like x + y , or calculate the dot product as x * y . Additionally, x ** f scales a vector x by the polynomial f , which is useful for constructing digital signatures.","title":"Under the Hood"},{"location":"under_the_hood/#class-details","text":"This package handles three fundamental objects: LatticeParameters, Polynomial, and PolynomialVector. The Polynomial and PolynomialVector objects have a LatticeParameters attribute, and the package handles computations with Polynomial and PolynomialVector objects with matching LatticeParameters.","title":"Class Details"},{"location":"under_the_hood/#latticeparameters","text":"The LatticeParameters class contains attributes describing the ring R , namely the degree d , the module length l , and the modulus q . From these, additional data are pre-computed for use in various algorithms later. We instantiate a LatticeParameters object by specifying the degree, length, and modulus in the following way. lp = LatticeParameters(degree=2**10, length=2**4, modulus=12289) We must instantiate LatticeParameters objects by passing in degree, length, and modulus. These must all be positive integers such that the degree is a power of two and (modulus - 1) % (2 * degree) == 0 otherwise a ValueError is raised.","title":"LatticeParameters"},{"location":"under_the_hood/#polynomial","text":"","title":"Polynomial"},{"location":"under_the_hood/#attributes-and-instantiation","text":"The Polynomial and PolynomialVector objects have a LatticeParameters attribute, lp , and the package handles computations with Polynomial and PolynomialVector objects with matching LatticeParameters. Other than the LatticeParameters object attached to each Polynomial, the Polynomial object also has an ntt_representation attribute, which is a list of integers. To instantiate a Polynomial, we pass in the coefficient representation of the polynomial as a dictionary of key-value pairs, where the keys are integers in the set [0, 1, ..., degree - 1] and the value associated with a key is the coefficient of the associated monomial, which is assumed to be a representative of an equivalence class of integers modulo modulus . The coefficients are centralized to be in the list [-(modulus//2), -(modulus//2)+1, ..., modulus//2 - 1, modulus//2] with constant-time modular arithmetic. For example, if modulus = 61 and we want to represent 3 * X**2 + 9 * X + 17 , we see the coefficient on the monomial X**0 = 1 is 17 , the coefficient on the monomial X is 9 , and the coefficient on the monomial X**2 is 3 . So we can pack the coefficient representation of this polynomial into a dictionary like {0: 17, 1: 9, 2: 3} . So, to create a Polynomial object representing this polynomial, we use the following. f = Polynomial(pars=lp, coefs={0: 17, 1: 9, 2: 3})","title":"Attributes and Instantiation"},{"location":"under_the_hood/#arithmetic","text":"Polynomials support __add__ , __radd__ , __sub__ , __mul__ , and __rmul__ . Thus, for two polynomials, say f and g , we simply use f + g , f - g , and f*g for addition, subtraction, and multiplication. Arithmetic for these operations take place coordinate-wise with the ntt_representation list, so they are very fast.","title":"Arithmetic"},{"location":"under_the_hood/#polynomial-norm-weight-and-string-representation","text":"Polynomials have a cooefficient_representation_and_norm_and_weight method, which inverts the ntt_representation list to obtain the coefficient representation of the polynomial, and returns this coefficient representation together with the infinity norm and the Hamming weight of the polynomial. The package uses __repr___ to cast the output of get_coef_rep as a string. WARNING : Computing the ntt_representation requires computing the NTT of the polynomial, and calling get_coef_rep requires computing the inverse NTT of the polynomial. These are relatively expensive operations compared to arithmetic. Hence, creating polynomials , printing them to strings , and computing the norm and weight of polynomials should be done once, after all other computations are complete.","title":"Polynomial Norm, Weight, and String Representation"},{"location":"under_the_hood/#polynomialvector","text":"","title":"PolynomialVector"},{"location":"under_the_hood/#polynomialvector-attributes-and-instantiation","text":"The Polynomial and PolynomialVector objects have a LatticeParameters attribute, par , and the package handles computations with Polynomial and PolynomialVector objects with matching LatticeParameters. Other than the LatticeParameters object attached to each PolynomialVector has an entries attribute, which is just a list of Polynomial objects. To instantiate a PolynomialVector, we pass in a list of Polynomial objects as the entries. For example, if f is the Polynomial from the previous section and g(X) = -17 + 12 * X ** 2 , we can create g and create a PolynomialVector object in the following way. g = Polynomial(pars=lp, coefs={0: -17, 2: 12}) v = PolynomialVector(pars=lp, entries=[f, g]) Each Polynomial in entries must have the same LatticeParameters object as v and we must have len(entries) == lp.length .","title":"PolynomialVector Attributes and Instantiation"},{"location":"under_the_hood/#polynomialvector-addition-subtraction-scaling-and-dot-products","text":"PolynomialVector objects support __add__ , __radd__ , and __sub__ to define addition and subtraction between PolynomialVector objects. This way, for two PolynomialVector objects, say v and w , we can just use v + w and v - w to compute the sum and difference, respectively. The package uses __mul__ and __rmul__ to define the dot product between two PolynomialVector objects. The dot product outputs a Polynomial object. For example, if v.entries == [f, g] and w.entries == [a, b] , then v * w returns f * a + g * b . The package repurposes __pow__ to scale a PolynomialVector by a Polynomial. For example, if v.entries = [f, g] and a is some Polynomial object, then v ** a = [a * f, a * g] . This is not exponentiation, although we use the notation for exponentiation. Hence, to compute a linear combination of PolynomialVectors whose coefficients are Polynomials, we compute the sum of \"exponents\" with something like this: sum(f ** a for f, a in zip(some_polynomial_vectors, some_polynomials)) . As before, arithmetic operations are done using the ntt_representation of the involved polynomials, and are thus quite fast.","title":"PolynomialVector Addition, Subtraction, Scaling, and Dot Products"},{"location":"under_the_hood/#polynomialvector-norm-weight-and-string-representation","text":"The string representation of a PolynomialVector, defined in __repr__ is merely str(entries) . WARNING : Like for Polynomial , instantiation requires computing the NTT of polynomials. So our previous warning about the cost of computing the NTT and the inverse NTT applies here, but with the added curse of dimensionality.","title":"PolynomialVector Norm, Weight, and String Representation."}]}